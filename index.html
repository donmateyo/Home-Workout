<!doctype html>
<html lang="en">
  <head>
    <!-- Fit Forge — single-file PWA (v9)
         Updates:
         • Custom icon (kettlebell + dumbbell) generated via Canvas and served as real PNG URLs
         • Robust iOS Home Screen icon delivery: SW matches by filename (works in subfolders)
         • Version bump to v9 so the new icon takes effect
         • All else unchanged -->
    <meta charset="utf-8" >
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no"
    >
    <meta name="theme-color" content="#0E0E10" >
    <meta name="apple-mobile-web-app-capable" content="yes" >
    <meta name="apple-mobile-web-app-title" content="Fit Forge" >
    <meta name="apple-mobile-web-app-status-bar-style" content="black" >
    <meta name="format-detection" content="telephone=no" >
    <title>Fit Forge — Simple, Spine-Smart Strength</title>
    <meta
      name="description"
      content="Fit Forge: spine-smart strength PWA with warm-up gate, Add-Before-You-Load progression, per-set timers, quick logging, and per-routine metrics."
    >

    <!-- iOS icons - data URLs injected by script -->
    <link rel="apple-touch-icon" id="apple-touch-icon-default" href="" >
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      id="apple-touch-icon-180"
      href=""
    >
    <link
      rel="apple-touch-icon"
      sizes="167x167"
      id="apple-touch-icon-167"
      href=""
    >
    <link
      rel="apple-touch-icon"
      sizes="152x152"
      id="apple-touch-icon-152"
      href=""
    >
    <link
      rel="apple-touch-icon-precomposed"
      id="apple-touch-icon-precomposed"
      href=""
    >

    <!-- Favicons for Android/desktop -->
    <link rel="icon" type="image/png" sizes="192x192" id="favicon-192" href="" >
    <link rel="icon" type="image/png" sizes="512x512" id="favicon-512" href="" >

    <style>
      :root {
        --bg: #0e0e10;
        --surface: #141419;
        --card: #17171d;
        --card-2: #1b1c22;
        --line: #262833;
        --text: #e6e7eb;
        --muted: #9aa3ad;
        --accent: #ef4444;
        --ok: #22c55e;
        --warn: #f59e0b;

        --pad-top: calc(env(safe-area-inset-top, 0px) + 8px);
        --pad-bottom: calc(env(safe-area-inset-bottom, 0px) + 8px);
        --touch: 48px;
        --radius: 14px;
      }

      * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica,
          Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }

      #app {
        display: grid;
        grid-template-rows: auto 1fr auto;
        height: 100dvh;
        width: 100vw;
        overflow: hidden;
      }

      header {
        position: sticky;
        top: 0;
        z-index: 5;
        background: var(--surface);
        border-bottom: 1px solid var(--line);
        padding: var(--pad-top) 14px 8px 14px;
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
        align-items: center;
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .logo {
        width: 30px;
        height: 30px;
        border-radius: 8px;
        background-size: cover;
        background-position: center;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
      }

      .title {
        font-weight: 800;
        letter-spacing: 0.2px;
      }

      .timer-chip {
        justify-self: end;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 999px;
        background: var(--card);
        border: 1px solid var(--line);
        font-variant-numeric: tabular-nums;
      }

      main {
        overflow: auto;
        padding: 10px 14px;
      }

      .card {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: var(--radius);
        padding: 12px;
      }

      .stack {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      .h {
        font-weight: 800;
        margin-bottom: 6px;
      }

      .sub {
        color: var(--muted);
        font-size: 13px;
      }

      .pill {
        border: 1px solid var(--line);
        background: var(--card-2);
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 13px;
      }

      .btn {
        height: var(--touch);
        padding: 0 14px;
        border-radius: 12px;
        border: 1px solid var(--line);
        background: var(--card-2);
        color: var(--text);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        cursor: pointer;
        user-select: none;
        touch-action: manipulation;
        font-size: 16px; /* avoid iOS zoom on press */
      }

      .btn.primary {
        background: var(--accent);
        border-color: #b91c1c;
        color: #fff;
      }

      .btn.block {
        width: 100%;
      }

      input,
      select,
      button {
        background: var(--surface);
        color: var(--text);
        border: 1px solid var(--line);
        border-radius: 10px;
        height: var(--touch);
        padding: 0 12px;
        font-size: 16px; /* Prevent iOS auto-zoom on focus */
      }

      button {
        background: var(--card-2);
        border: 1px solid var(--line);
      }

      .hr {
        height: 1px;
        background: var(--line);
        border-radius: 1px;
        margin: 6px 0;
      }

      .warn {
        color: var(--warn);
      }

      nav {
        position: sticky;
        bottom: 0;
        z-index: 4;
        background: var(--surface);
        border-top: 1px solid var(--line);
        padding: 6px 8px calc(6px + var(--pad-bottom)) 8px;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 6px;
      }

      .tab {
        text-align: center;
        padding: 10px 6px;
        border-radius: 12px;
        color: var(--muted);
        user-select: none;
        touch-action: manipulation;
      }

      .tab.active {
        background: rgba(255, 255, 255, 0.05);
        color: #fff;
      }

      .ex {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
      }

      .ex .name {
        font-weight: 700;
      }

      .ex .meta {
        grid-column: 1 / -1;
        color: var(--muted);
        font-size: 13px;
      }

      .chips {
        display: inline-flex;
        gap: 6px;
        align-items: center;
      }

      .chip {
        width: 28px;
        height: 28px;
        border-radius: 14px;
        border: 1px solid var(--line);
        background: var(--surface);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        cursor: pointer;
        user-select: none;
        touch-action: manipulation;
      }

      .chip.done {
        background: #142116;
        color: #86efac;
        border-color: #14532d;
      }

      .cue {
        font-size: 13px;
        background: var(--card-2);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
        color: var(--muted);
      }

      .restbar {
        height: 12px;
        background: #111216;
        border: 1px solid var(--line);
        border-radius: 999px;
        overflow: hidden;
      }

      .restbar span {
        display: block;
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #22c55e, #0ea5e9);
        transition: width 0.25s linear;
      }

      .toast {
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
        bottom: calc(80px + var(--pad-bottom));
        background: var(--surface);
        border: 1px solid var(--line);
        color: var(--text);
        padding: 10px 14px;
        border-radius: 12px;
        z-index: 1000;
        box-shadow: 0 16px 34px rgba(0, 0, 0, 0.35);
      }

      /* Quick Log bottom sheet */
      .sheet-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.45);
        display: flex;
        align-items: flex-end;
        justify-content: center;
        z-index: 1001;
      }

      .sheet {
        width: 100%;
        background: var(--card);
        border-top-left-radius: 16px;
        border-top-right-radius: 16px;
        border: 1px solid var(--line);
        padding: 12px;
        padding-bottom: calc(12px + var(--pad-bottom));
      }

      .sheet .title {
        font-weight: 800;
        margin-bottom: 8px;
      }

      .sheet .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      .sheet .row {
        justify-content: space-between;
      }

      .sheet .btn {
        flex: 1;
      }
    </style>
  </head>
  <body>
    <div id="app" aria-live="polite"></div>

    <script>
      // Fit Forge — PWA (v10) - Enhanced custom icons
      // - Improved kettlebell + dumbbell icon with better shading and depth
      // - More professional and polished visual appearance
      // - Enhanced highlights, shadows, and composition

      // Store generated icon globally for header use
      let generatedIconDataURL = null;

      // Manifest + Service Worker (serves real icon URLs)
      (function pwa() {
        // 1) Draw icon via Canvas -> base64 PNG (no external assets)
        function roundedRectPath(ctx, x, y, w, h, r) {
          const rr = Math.min(r, w / 2, h / 2);
          ctx.beginPath();
          ctx.moveTo(x + rr, y);
          ctx.arcTo(x + w, y, x + w, y + h, rr);
          ctx.arcTo(x + w, y + h, x, y + h, rr);
          ctx.arcTo(x, y + h, x, y, rr);
          ctx.arcTo(x, y, x + w, y, rr);
          ctx.closePath();
        }

        function drawIronIcon(ctx, size) {
          const s = size / 100; // normalize to 100x100 units
          ctx.save();

          // Background gradient - richer, more depth
          const bg = ctx.createLinearGradient(0, 0, size, size);
          bg.addColorStop(0, "#f87171");
          bg.addColorStop(0.5, "#ef4444");
          bg.addColorStop(1, "#991b1b");
          ctx.fillStyle = bg;
          ctx.fillRect(0, 0, size, size);

          // Deeper vignette for more depth
          const vign = ctx.createRadialGradient(
            size * 0.5, size * 0.5, size * 0.2,
            size * 0.5, size * 0.5, size * 0.85
          );
          vign.addColorStop(0, "rgba(0,0,0,0)");
          vign.addColorStop(1, "rgba(0,0,0,0.4)");
          ctx.fillStyle = vign;
          ctx.fillRect(0, 0, size, size);

          // Top highlight for dimension
          const hi = ctx.createRadialGradient(
            size * 0.3, size * 0.2, size * 0.05,
            size * 0.3, size * 0.2, size * 0.45
          );
          hi.addColorStop(0, "rgba(255,255,255,0.25)");
          hi.addColorStop(1, "rgba(255,255,255,0)");
          ctx.fillStyle = hi;
          ctx.fillRect(0, 0, size, size);

          // Kettlebell (left side, better positioned)
          ctx.save();
          ctx.shadowColor = "rgba(0,0,0,0.5)";
          ctx.shadowBlur = 10 * s;
          ctx.shadowOffsetX = 1 * s;
          ctx.shadowOffsetY = 3 * s;

          const kx = 32 * s;
          const ky = 58 * s;

          // Main body - more realistic shape
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.ellipse(kx, ky, 19 * s, 17 * s, 0, 0, Math.PI * 2);
          ctx.fill();

          // Neck connecting to handle
          roundedRectPath(ctx, kx - 9 * s, ky - 18 * s, 18 * s, 10 * s, 4 * s);
          ctx.fill();

          // Handle outer ring
          roundedRectPath(ctx, kx - 15 * s, ky - 32 * s, 30 * s, 16 * s, 8 * s);
          ctx.fill();

          // Cut handle hole
          ctx.globalCompositeOperation = "destination-out";
          ctx.shadowColor = "transparent";
          roundedRectPath(ctx, kx - 10 * s, ky - 28 * s, 20 * s, 8 * s, 4 * s);
          ctx.fill();
          ctx.globalCompositeOperation = "source-over";

          // Add inner shadow to handle hole for depth
          ctx.save();
          ctx.shadowColor = "rgba(0,0,0,0.3)";
          ctx.shadowBlur = 3 * s;
          ctx.shadowOffsetY = -1 * s;
          ctx.globalCompositeOperation = "source-atop";
          ctx.strokeStyle = "rgba(0,0,0,0.15)";
          ctx.lineWidth = 1.5 * s;
          roundedRectPath(ctx, kx - 10 * s, ky - 28 * s, 20 * s, 8 * s, 4 * s);
          ctx.stroke();
          ctx.restore();

          // Highlight on kettlebell body
          ctx.save();
          ctx.globalAlpha = 0.3;
          const kbHighlight = ctx.createRadialGradient(
            kx - 6 * s, ky - 5 * s, 0,
            kx - 6 * s, ky - 5 * s, 14 * s
          );
          kbHighlight.addColorStop(0, "rgba(255,255,255,1)");
          kbHighlight.addColorStop(1, "rgba(255,255,255,0)");
          ctx.fillStyle = kbHighlight;
          ctx.beginPath();
          ctx.ellipse(kx - 4 * s, ky - 3 * s, 12 * s, 10 * s, -0.3, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          ctx.restore();

          // Dumbbell (right side, tilted for visual interest)
          ctx.save();
          ctx.translate(70 * s, 50 * s);
          ctx.rotate(-12 * Math.PI / 180);
          ctx.shadowColor = "rgba(0,0,0,0.5)";
          ctx.shadowBlur = 9 * s;
          ctx.shadowOffsetX = 1 * s;
          ctx.shadowOffsetY = 3 * s;

          // Bar/handle
          ctx.fillStyle = "#ffffff";
          roundedRectPath(ctx, -22 * s, -3.5 * s, 44 * s, 7 * s, 3.5 * s);
          ctx.fill();

          // Bar highlight
          ctx.save();
          ctx.globalAlpha = 0.4;
          const barHighlight = ctx.createLinearGradient(0, -3.5 * s, 0, 3.5 * s);
          barHighlight.addColorStop(0, "rgba(255,255,255,1)");
          barHighlight.addColorStop(0.5, "rgba(255,255,255,0)");
          barHighlight.addColorStop(1, "rgba(0,0,0,0.1)");
          ctx.fillStyle = barHighlight;
          roundedRectPath(ctx, -22 * s, -3.5 * s, 44 * s, 7 * s, 3.5 * s);
          ctx.fill();
          ctx.restore();

          // Weight plates function with better detail
          function plate(x, wOuter, hOuter, wInner, hInner) {
            // Outer plate
            ctx.fillStyle = "#ffffff";
            roundedRectPath(ctx, x - wOuter, -hOuter / 2, wOuter, hOuter, 2.5 * s);
            ctx.fill();

            // Plate edge detail
            ctx.save();
            ctx.globalAlpha = 0.15;
            ctx.fillStyle = "#000000";
            roundedRectPath(ctx, x - wOuter + 1 * s, -hOuter / 2 + 1 * s, wOuter - 2 * s, hOuter - 2 * s, 2 * s);
            ctx.fill();
            ctx.restore();

            // Inner plate
            ctx.fillStyle = "#ffffff";
            const ix = x - (wInner + 2.5 * s);
            roundedRectPath(ctx, ix, -hInner / 2, wInner, hInner, 2 * s);
            ctx.fill();

            // Plate highlight
            ctx.save();
            ctx.globalAlpha = 0.35;
            const plateHighlight = ctx.createLinearGradient(x - wOuter, -hOuter / 2, x - wOuter, hOuter / 2);
            plateHighlight.addColorStop(0, "rgba(255,255,255,1)");
            plateHighlight.addColorStop(0.6, "rgba(255,255,255,0)");
            ctx.fillStyle = plateHighlight;
            roundedRectPath(ctx, x - wOuter, -hOuter / 2, wOuter, hOuter, 2.5 * s);
            ctx.fill();
            ctx.restore();
          }

          // Left plates
          plate(-24 * s, 11 * s, 18 * s, 8 * s, 14 * s);

          // Right plates (mirror)
          ctx.scale(-1, 1);
          plate(-24 * s, 11 * s, 18 * s, 8 * s, 14 * s);

          ctx.restore();

          // Subtle accent glow around entire composition
          ctx.save();
          ctx.globalAlpha = 0.06;
          const accentGlow = ctx.createRadialGradient(
            size * 0.5, size * 0.5, size * 0.3,
            size * 0.5, size * 0.5, size * 0.7
          );
          accentGlow.addColorStop(0, "rgba(255,255,255,0.3)");
          accentGlow.addColorStop(1, "rgba(255,255,255,0)");
          ctx.fillStyle = accentGlow;
          ctx.fillRect(0, 0, size, size);
          ctx.restore();

          ctx.restore();
        }

        function generateIconB64(size) {
          const c = document.createElement("canvas");
          c.width = c.height = size;
          const ctx = c.getContext("2d");
          drawIronIcon(ctx, size);
          const dataURL = c.toDataURL("image/png");
          return dataURL.slice(dataURL.indexOf(",") + 1); // pure base64
        }

        function generateIconDataURL(size) {
          const c = document.createElement("canvas");
          c.width = c.height = size;
          const ctx = c.getContext("2d");
          drawIronIcon(ctx, size);
          return c.toDataURL("image/png");
        }

        // Store icon for header use
        generatedIconDataURL = generateIconDataURL(120);

        // Generate all required sizes as data URLs for direct embedding
        const ICON_180_URL = generateIconDataURL(180);
        const ICON_167_URL = generateIconDataURL(167);
        const ICON_152_URL = generateIconDataURL(152);
        const ICON_192_URL = generateIconDataURL(192);
        const ICON_512_URL = generateIconDataURL(512);

        // Inject data URLs into link elements immediately
        const iconLinks = {
          'apple-touch-icon-default': ICON_180_URL,
          'apple-touch-icon-180': ICON_180_URL,
          'apple-touch-icon-167': ICON_167_URL,
          'apple-touch-icon-152': ICON_152_URL,
          'apple-touch-icon-precomposed': ICON_180_URL,
          'favicon-192': ICON_192_URL,
          'favicon-512': ICON_512_URL
        };

        Object.keys(iconLinks).forEach(id => {
          const link = document.getElementById(id);
          if (link) {
            link.href = iconLinks[id];
          }
        });

        // Also generate base64 for service worker
        const ICON_180 = generateIconB64(180);
        const ICON_167 = generateIconB64(167);
        const ICON_152 = generateIconB64(152);
        const ICON_192 = generateIconB64(192);
        const ICON_512 = generateIconB64(512);

        // 2) Manifest
        const manifest = {
          name: "Fit Forge — Build Iron. Guard Your Spine.",
          short_name: "Fit Forge",
          start_url: "./index.html",
          display: "standalone",
          background_color: "#0E0E10",
          theme_color: "#0E0E10",
          categories: ["health", "fitness", "education"],
          icons: [
            {
              src: "icons/icon-192.png",
              sizes: "192x192",
              type: "image/png",
              purpose: "any maskable",
            },
            {
              src: "icons/icon-512.png",
              sizes: "512x512",
              type: "image/png",
              purpose: "any maskable",
            },
          ],
        };

        const m = new Blob([JSON.stringify(manifest)], {
          type: "application/manifest+json",
        });
        const mu = URL.createObjectURL(m);
        const link = document.createElement("link");
        link.rel = "manifest";
        link.href = mu;
        document.head.appendChild(link);

        // 3) Service Worker: serve icon URLs with real PNG bytes + cache index
        const sw = `
          const CACHE="fitforge-v10";

          // Map base filenames -> base64 PNG
          const FILE_ICONS = new Map([
            ["apple-touch-icon.png","${ICON_180}"],
            ["apple-touch-icon-precomposed.png","${ICON_180}"],
            ["apple-touch-icon-180x180.png","${ICON_180}"],
            ["apple-touch-icon-167x167.png","${ICON_167}"],
            ["apple-touch-icon-152x152.png","${ICON_152}"],
            ["icon-192.png","${ICON_192}"],
            ["icon-512.png","${ICON_512}"]
          ]);

          function b64ToUint8(b64){
            const bin = atob(b64);
            const len = bin.length;
            const bytes = new Uint8Array(len);
            for (let i=0;i<len;i++) bytes[i]=bin.charCodeAt(i);
            return bytes;
          }
          function pngResponse(b64){
            return new Response(b64ToUint8(b64), {
              headers: {
                "Content-Type": "image/png",
                "Cache-Control": "public, max-age=31536000, immutable"
              }
            });
          }

          self.addEventListener("install", (e) => {
            e.waitUntil(caches.open(CACHE).then(c=>c.addAll(["./index.html"]).catch(()=>{})));
            self.skipWaiting();
          });

          self.addEventListener("activate", (e) => {
            e.waitUntil(self.clients.claim());
          });

          self.addEventListener("fetch", (e) => {
            const url = new URL(e.request.url);
            const path = url.pathname;
            const name = path.split("/").pop();

            // Serve any of the icon filenames regardless of folder depth
            if (FILE_ICONS.has(name)) {
              e.respondWith(pngResponse(FILE_ICONS.get(name)));
              return;
            }

            // Basic app shell caching
            if (path === "/" || path.endsWith("/index.html")) {
              e.respondWith(
                caches.open(CACHE).then(async (c) => {
                  const cached = await c.match("./index.html");
                  const fetcher = fetch(e.request).then((r) => {
                    c.put("./index.html", r.clone());
                    return r;
                  }).catch(()=>cached);
                  return cached || fetcher;
                })
              );
              return;
            }

            e.respondWith(
              caches.match(e.request).then((cRes) => {
                const net = fetch(e.request).then((nRes) => {
                  if (nRes && nRes.status === 200 && nRes.type === "basic") {
                    const copy = nRes.clone();
                    caches.open(CACHE).then((c) => c.put(e.request, copy));
                  }
                  return nRes;
                }).catch(() => cRes);
                return cRes || net;
              })
            );
          });
        `;
        if ("serviceWorker" in navigator) {
          const swu = URL.createObjectURL(
            new Blob([sw], { type: "text/javascript" })
          );
          // Try to scope to root so icon paths resolve at domain root
          navigator.serviceWorker.register(swu, { scope: "/" }).catch(() => {
            // Fallback: default scope (icons still work via filename matching)
            navigator.serviceWorker.register(swu).catch(() => {});
          });
        }
      })();

      // Utilities
      const qs = (s, el = document) => el.querySelector(s);
      const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
      const nowISO = () => new Date().toISOString();
      const todayKey = () => new Date().toISOString().slice(0, 10);
      const uid = () =>
        Math.random().toString(36).slice(2) + Date.now().toString(36);

      const Beep = (() => {
        let ctx;
        function ensure() {
          ctx =
            ctx ||
            new (window.AudioContext || window.webkitAudioContext)();
        }
        function beep(f = 880, d = 120, v = 0.03) {
          try {
            ensure();
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            o.type = "sine";
            o.frequency.value = f;
            g.gain.value = v;
            o.connect(g);
            g.connect(ctx.destination);
            o.start();
            setTimeout(() => o.stop(), d);
          } catch {}
        }
        return { beep };
      })();

      function toast(msg, ms = 2200) {
        const t = document.createElement("div");
        t.className = "toast";
        t.textContent = msg;
        document.body.appendChild(t);
        setTimeout(() => t.remove(), ms);
      }

      function showConfirmDialog(message, onConfirm) {
        const modal = document.createElement("div");
        modal.className = "sheet-backdrop";
        modal.innerHTML = `
          <div class="sheet" style="border-radius: 16px; max-width: 400px; padding: 20px;">
            <div style="font-weight: 700; margin-bottom: 12px;">${message}</div>
            <div class="row" style="justify-content: flex-end; gap: 12px; margin-top: 16px;">
              <button class="btn" id="cancelBtn">Cancel</button>
              <button class="btn primary" id="confirmBtn" style="background: var(--accent);">Delete</button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);

        modal.querySelector("#cancelBtn").onclick = () => modal.remove();
        modal.querySelector("#confirmBtn").onclick = () => {
          modal.remove();
          onConfirm();
        };
        modal.onclick = (e) => {
          if (e.target === modal) modal.remove();
        };
      }

      function mmss(ms) {
        const t = Math.max(0, Math.floor(ms / 1000));
        const h = Math.floor(t / 3600);
        const m = Math.floor((h ? t - h * 3600 : t) / 60);
        const s = t % 60;
        return (h ? h + ":" : "") + String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
      }

      // Program
      const Warmup = [
        ["Cat-Cow", "5 reps", "Explore range, no forcing."],
        ["Dead Bug", "8/side", "Press back into floor."],
        ["Bird-Dog", "8/side", "Slow, hold 2 sec."],
        ["Glute Bridge", "15 reps", "Squeeze, don't yank."],
        ["KB Halo", "8/side @ 35 lb", "Wake up the T-spine."],
      ];

      const Tracks = {
        Hybrid: {
          id: "Hybrid",
          title: "Hybrid",
          subtitle: "The Bodyweight–Iron Mashup",
          restPolicy: "60-90",
          exercises: [
            {
              id: "goblet-box-squat",
              name: "Goblet Box Squat",
              sets: [3, 4],
              reps: [8, 12],
              load: 35,
              cues: ["Box = depth police.", "Brace down, exhale up."],
            },
            {
              id: "kb-swing",
              name: "KB Swing",
              sets: [3, 4],
              reps: [15, 20],
              load: 35,
              cues: [
                "Hinge, not squat. Butt to wall.",
                "Arms are ropes. Top = plank.",
              ],
              constitution: "swing",
            },
            {
              id: "floor-press",
              name: "Floor Press",
              sets: [3, 4],
              reps: [8, 12],
              load: 25,
              cues: ["Controlled pause at floor."],
            },
            {
              id: "sa-db-row",
              name: "Single-Arm DB Row",
              sets: [3, 4],
              reps: [10, 12],
              load: 25,
              cues: ["Flat back, brace.", "Elbow back; squeeze blade."],
              constitution: "row",
            },
            {
              id: "hip-thrust",
              name: "Hip Thrust",
              sets: [3, 4],
              reps: [12, 15],
              load: 35,
              cues: ["Lock out with glutes, not low back."],
            },
            {
              id: "hollow-hold",
              name: "Hollow Body Hold",
              sets: [3, 3],
              timeSec: [20, 40],
              load: 0,
              cues: ["Posterior tilt. Bend knees if needed."],
            },
            {
              id: "suitcase-carry",
              name: "Suitcase Carry",
              sets: [3, 3],
              timeSec: [45, 60],
              load: 35,
              cues: ["No side-bend. Tall. Slow steps."],
            },
          ],
        },
        IronFocused: {
          id: "IronFocused",
          title: "Iron-Focused: The Backsmith's Anvil Day",
          subtitle: "Heavier day, form is king",
          restPolicy: "90-120",
          exercises: [
            {
              id: "heavy-goblet-squat",
              name: "Heavy Goblet Squat",
              sets: [4, 4],
              reps: [6, 10],
              load: 50,
              cues: ["70 is spicy—only with a steel brace."],
            },
            {
              id: "heavy-kb-swing",
              name: "Heavy KB Swing",
              sets: [4, 4],
              reps: [15, 20],
              load: 50,
              cues: ["Form is king. Top = plank."],
              constitution: "swing",
            },
            {
              id: "floor-press-heavy",
              name: "Floor Press",
              sets: [3, 4],
              reps: [6, 8],
              load: 35,
              cues: ["Heavy, controlled pause at chest."],
            },
            {
              id: "bent-over-row",
              name: "Bent-Over DB Row",
              sets: [4, 4],
              reps: [8, 10],
              load: 35,
              cues: ["Flat back, deep hinge, brace."],
              constitution: "row",
            },
            {
              id: "heavy-hip-thrust",
              name: "Heavy Hip Thrust",
              sets: [4, 4],
              reps: [10, 12],
              load: 50,
              cues: ["Lock out with glutes, not low back."],
            },
            {
              id: "dead-bug-oh",
              name: "Dead Bug w/ KB Overhead",
              sets: [3, 3],
              reps: [8, 10],
              load: 15,
              cues: ["Active spine protection."],
            },
            {
              id: "suitcase-carry-heavy",
              name: "Suitcase Carry",
              sets: [3, 3],
              timeSec: [60, 60],
              load: 50,
              cues: ["Grip. Core. Grit."],
            },
          ],
        },
        GrumpyBack: {
          id: "GrumpyBack",
          title: "Grumpy Back Day",
          subtitle: "Plan B: light, spine-friendly swaps",
          restPolicy: "60-90",
        },
      };

      const Constitution = {
        swing: [
          "Hinge at hips; butt to wall.",
          "Arms as ropes; bell as pendulum.",
          "Brace before hike. Ribs down.",
          "Top = plank; bell ≤ chest.",
          "No rounding at bottom.",
        ],
        row: [
          "Hinge ~45°; feel hamstrings.",
          "Back flat as a table.",
          "Inhale, brace, pull; exhale top.",
          "Elbow drives back; squeeze blade.",
          "No twisting; drop weight if needed.",
        ],
      };

      // Light loads for Grumpy Back
      function lightKbLoad() {
        const s = Store.get();
        const arr = s.profile.equipment.kb || [];
        return arr.length ? Math.min(...arr) : 20;
      }
      function lightDbLoad() {
        const s = Store.get();
        const arr = s.profile.equipment.db || [];
        return arr.length ? Math.min(...arr) : 10;
      }
      function planBExercises() {
        return [
          {
            id: "pb-squat",
            name: "Goblet Box Squat (light)",
            sets: [2, 2],
            reps: [10, 12],
            load: lightKbLoad(),
            cues: ["Smooth, no grind."],
          },
          {
            id: "pb-hipthrust",
            name: "Hip Thrusts",
            sets: [2, 2],
            reps: [12, 15],
            load: lightKbLoad(),
            cues: ["Squeeze glutes at top."],
          },
          {
            id: "pb-floorpress",
            name: "Floor Press",
            sets: [2, 2],
            reps: [8, 10],
            load: lightDbLoad(),
            cues: ["Controlled tempo."],
          },
          {
            id: "pb-deadbug",
            name: "Dead Bug",
            sets: [2, 2],
            reps: [8, 8],
            load: 0,
            cues: ["Low back glued to floor."],
          },
          {
            id: "pb-carry",
            name: "Suitcase Carry (light, slow)",
            sets: [2, 2],
            timeSec: [45, 60],
            load: lightKbLoad(),
            cues: ["No side-bend. Tall."],
          },
        ];
      }

      // Store
      const Store = (() => {
        const KEY = "fitforge.v8"; // kept for user data stability
        let state = load() || seed();
        function seed() {
          return {
            profile: {
              name: "Mateo",
              unit: "lb",
              equipment: { kb: [35, 50, 70], db: [25, 35] },
              track: "Hybrid", // "Hybrid" | "IronFocused" | "GrumpyBack"
              schedule: [1, 3, 5],
              startDate: nowISO(),
            },
            runtime: {
              warmupDoneKey: null,
              workoutActive: false,
              workoutStart: 0,
              workoutAccum: 0,
              lastTotalSec: 0,
            },
            logs: [], // {id,date,workoutId,totalSec,sets[]}
          };
        }
        function load() {
          try {
            // eslint-disable-next-line no-restricted-globals
            const s = localStorage.getItem(KEY);
            return s ? JSON.parse(s) : null;
          } catch {
            return null;
          }
        }
        function save() {
          // eslint-disable-next-line no-restricted-globals
          localStorage.setItem(KEY, JSON.stringify(state));
          return state;
        }
        return {
          get: () => state,
          patch: (p) => {
            state = Object.assign({}, state, p);
            return save();
          },
          mutate: (fn) => {
            fn(state);
            return save();
          },
          reset: () => {
            state = seed();
            return save();
          },
        };
      })();

      // Progression (Add-Before-You-Load: simplified)
      function prescribeNext({
        week,
        lastFormAvg = 90,
        lastRpeAvg = 7,
        hitTopReps = true,
        currentSets = 4,
        currentTempo = "2-0-1",
        currentWeightLb = 0,
      }) {
        const perfect = lastFormAvg >= 85 && lastRpeAvg <= 8 && hitTopReps;
        if (week <= 2) {
          return {
            sets: Math.max(3, currentSets),
            tempo: "2-0-1",
            weightLb: currentWeightLb,
          };
        }
        if (week <= 4) {
          if (currentSets < 4 && perfect) {
            return { sets: 4, tempo: currentTempo, weightLb: currentWeightLb };
          }
          return { sets: currentSets, tempo: "4-0-1", weightLb: currentWeightLb };
        }
        if (perfect) {
          return {
            sets: currentSets,
            tempo: "2-0-1",
            weightLb: currentWeightLb ? currentWeightLb + 5 : undefined,
          };
        }
        return { sets: currentSets, tempo: currentTempo, weightLb: currentWeightLb };
      }

      // Workout Timers (overall)
      let tickId = null;
      function startWorkoutTimer() {
        const s = Store.get();
        if (s.runtime.workoutActive) return;
        Store.mutate((st) => {
          st.runtime.workoutActive = true;
          st.runtime.workoutStart = Date.now();
        });
        tick();
        toast("Workout timer started.");
      }
      function pauseWorkoutTimer() {
        const s = Store.get();
        if (!s.runtime.workoutActive) return;
        Store.mutate((st) => {
          const elapsed = Date.now() - st.runtime.workoutStart;
          st.runtime.workoutAccum += elapsed;
          st.runtime.workoutStart = 0;
          st.runtime.workoutActive = false;
        });
        if (tickId) clearInterval(tickId);
        renderTimerChip();
        toast("Workout paused.");
      }
      function stopWorkoutTimer() {
        const s = Store.get();
        let total = s.runtime.workoutAccum;
        if (s.runtime.workoutActive) {
          total += Date.now() - s.runtime.workoutStart;
        }
        Store.mutate((st) => {
          st.runtime.lastTotalSec = Math.round(total / 1000);
          st.runtime.workoutAccum = 0;
          st.runtime.workoutStart = 0;
          st.runtime.workoutActive = false;
        });
        if (tickId) clearInterval(tickId);
        renderTimerChip();
      }
      function getWorkoutElapsedMs() {
        const s = Store.get();
        let ms = s.runtime.workoutAccum;
        if (s.runtime.workoutActive) {
          ms += Date.now() - s.runtime.workoutStart;
        }
        return ms;
      }
      function tick() {
        if (tickId) clearInterval(tickId);
        tickId = setInterval(renderTimerChip, 1000);
      }

      // Per-exercise rest timer
      function restTimer(durationSec, onTick, onDone) {
        const start = Date.now();
        const dur = durationSec * 1000;
        let id = null;
        function step() {
          const elapsed = Date.now() - start;
          const left = Math.max(0, dur - elapsed);
          onTick(Math.round(left / 1000), elapsed / dur);
          if (left <= 0) {
            clearInterval(id);
            Beep.beep(1200, 140, 0.06);
            Beep.beep(900, 160, 0.06);
            onDone && onDone();
          }
        }
        step();
        id = setInterval(step, 200);
        return () => clearInterval(id);
      }

      // Rendering
      function render() {
        const root = qs("#app");
        root.innerHTML = "";
        root.appendChild(appHeader());
        root.appendChild(appMain());
        root.appendChild(appNav());
        renderTimerChip();
      }

      function appHeader() {
        const h = document.createElement("header");
        const left = document.createElement("div");
        left.className = "brand";
        const logo = document.createElement("div");
        logo.className = "logo";
        if (generatedIconDataURL) {
          logo.style.backgroundImage = `url(${generatedIconDataURL})`;
        }
        const t = document.createElement("div");
        t.innerHTML = `<div class="title">Fit Forge</div>
          <div class="sub">Build Iron. Guard Your Spine.</div>`;
        left.appendChild(logo);
        left.appendChild(t);

        const chip = document.createElement("div");
        chip.className = "timer-chip";
        chip.id = "timerChip";
        chip.innerHTML = `
          <span id="timerTxt">00:00</span>
          <button class="btn" id="timerBtn" style="height:32px">Start</button>
        `;

        h.appendChild(left);
        h.appendChild(chip);
        return h;
      }

      function renderTimerChip() {
        const s = Store.get();
        const txt = qs("#timerTxt");
        const btn = qs("#timerBtn");
        if (!txt || !btn) return;
        txt.textContent = mmss(getWorkoutElapsedMs());
        if (s.runtime.workoutActive) {
          btn.textContent = "Pause";
          btn.onclick = () => pauseWorkoutTimer();
        } else {
          btn.textContent = "Start";
          btn.onclick = () => startWorkoutTimer();
        }
      }

      function appNav() {
        const nav = document.createElement("nav");
        const tabs = [
          ["workout", "Workout"],
          ["metrics", "Metrics"],
          ["learn", "Learn"],
        ];
        const cur = location.hash.replace("#", "") || "workout";
        tabs.forEach(([id, label]) => {
          const el = document.createElement("div");
          el.className = "tab" + (cur === id ? " active" : "");
          el.textContent = label;
          el.onclick = () => {
            location.hash = "#" + id;
            render();
          };
          nav.appendChild(el);
        });
        return nav;
      }

      function appMain() {
        const main = document.createElement("main");
        const cur = location.hash.replace("#", "") || "workout";
        if (cur === "workout") main.appendChild(viewWorkout());
        if (cur === "metrics") main.appendChild(viewMetrics());
        if (cur === "learn") main.appendChild(viewLearn());
        return main;
      }

      // Workout View
      function viewWorkout() {
        const wrap = document.createElement("div");
        wrap.className = "stack";
        wrap.appendChild(warmupCard());
        wrap.appendChild(todaysWorkoutCard());
        return wrap;
      }

      function warmupCard() {
        const card = document.createElement("div");
        card.className = "card";
        const s = Store.get();

        const hd = document.createElement("div");
        hd.className = "h";
        hd.textContent = "Warm-Up (Password)";
        const sub = document.createElement("div");
        sub.className = "sub";
        sub.textContent = "Do this every time. Unlocks the main session.";

        const list = document.createElement("div");
        list.className = "stack";
        list.style.marginTop = "4px";

        const today = todayKey();
        const done = s.runtime.warmupDoneKey === today;

        const checks = [];
        Warmup.forEach(([name, rep, cue]) => {
          const row = document.createElement("div");
          row.className = "row";
          const chk = document.createElement("input");
          chk.type = "checkbox";
          chk.disabled = done;
          const label = document.createElement("div");
          label.innerHTML = `<strong>${name}</strong> · ${rep}
            <div class="sub">${cue}</div>`;
          row.appendChild(chk);
          row.appendChild(label);
          list.appendChild(row);
          checks.push(chk);
        });

        const gate = document.createElement("button");
        gate.className = "btn primary block";
        gate.textContent = done ? "Warm-Up Completed" : "Unlock Main Session";
        gate.disabled = done;
        gate.onclick = () => {
          const ok = checks.every((c) => c.checked);
          if (!ok) {
            toast("Finish all warm-up items first.");
            return;
          }
          Store.mutate((st) => {
            st.runtime.warmupDoneKey = todayKey();
          });
          if (!Store.get().runtime.workoutActive) {
            startWorkoutTimer();
          }
          toast("Password accepted. Forge time.");
          render();
        };

        card.appendChild(hd);
        card.appendChild(sub);
        card.appendChild(list);
        card.appendChild(gate);
        return card;
      }

      function todaysWorkoutCard() {
        const s = Store.get();
        const card = document.createElement("div");
        card.className = "card";

        // Routine selector
        const routineRow = document.createElement("div");
        routineRow.className = "row";
        const routineLabel = document.createElement("div");
        routineLabel.className = "sub";
        routineLabel.textContent = "Routine";
        const routineSel = document.createElement("select");
        const opts = [
          ["Hybrid", "Hybrid"],
          ["IronFocused", "Iron-Focused: The Backsmith's Anvil Day"],
          ["GrumpyBack", "Grumpy Back Day"],
        ];
        opts.forEach(([v, t]) => {
          const op = document.createElement("option");
          op.value = v;
          op.textContent = t;
          if (s.profile.track === v) op.selected = true;
          routineSel.appendChild(op);
        });
        routineSel.onchange = () => {
          Store.mutate((st) => {
            st.profile.track = routineSel.value;
          });
          toast("Routine switched.");
          render();
        };
        routineRow.appendChild(routineLabel);
        routineRow.appendChild(routineSel);

        const track = Tracks[s.profile.track] || Tracks.Hybrid;

        const hd = document.createElement("div");
        hd.className = "h";
        hd.textContent = track.title;

        const sub = document.createElement("div");
        sub.className = "sub";
        const restHint =
          track.restPolicy === "90-120"
            ? "Rest aim: 90–120s."
            : "Rest aim: 60–90s.";
        sub.textContent =
          (track.subtitle ? track.subtitle + " · " : "") +
          restHint +
          " Auto rest after every set.";

        const warmOK = s.runtime.warmupDoneKey === todayKey();

        card.appendChild(routineRow);
        card.appendChild(hd);
        card.appendChild(sub);
        card.appendChild(divider());

        if (!warmOK) {
          const lock = document.createElement("div");
          lock.className = "pill warn";
          lock.textContent = "Locked: complete the warm-up to start.";
          card.appendChild(lock);
          return card;
        }

        const list = document.createElement("div");
        list.className = "stack";

        const week = weekFrom(s.profile.startDate);
        const restDefault =
          track.id === "IronFocused" ? 105 : track.id === "Hybrid" ? 75 : 60;

        if (track.id === "GrumpyBack") {
          const exs = planBExercises();
          exs.forEach((ex) => {
            list.appendChild(
              exerciseCard({
                id: ex.id,
                name: ex.name,
                sets: ex.sets[1],
                reps: ex.reps,
                timeSec: ex.timeSec,
                load: ex.load,
                cues: ex.cues,
                restSec: restDefault,
              })
            );
          });
          list.appendChild(walkCard());
        } else {
          track.exercises.forEach((ex) => {
            const last = lastAverages(ex.id);
            const p = prescribeNext({
              week,
              lastFormAvg: last.form,
              lastRpeAvg: last.rpe,
              hitTopReps: last.hitTop,
              currentSets: ex.sets[1],
              currentWeightLb: ex.load,
            });
            const sets = clamp(p.sets, ex.sets[0], ex.sets[1]);
            list.appendChild(
              exerciseCard({
                id: ex.id,
                name: ex.name,
                sets,
                reps: ex.reps,
                timeSec: ex.timeSec,
                load: p.weightLb || ex.load,
                cues: ex.cues,
                constitution: ex.constitution,
                restSec: restDefault,
              })
            );
          });
        }

        list.appendChild(finishRow());
        card.appendChild(list);
        return card;
      }

      function divider() {
        const d = document.createElement("div");
        d.className = "hr";
        return d;
      }

      function weekFrom(startISO) {
        const start = new Date(startISO);
        const now = new Date();
        const diff = now - start;
        return Math.max(1, Math.ceil(diff / (7 * 86400000)));
      }

      function lastAverages(exId) {
        const s = Store.get();
        const sets = s.logs
          .slice(-10)
          .flatMap((l) => l.sets)
          .filter((t) => t.exerciseId === exId);
        if (!sets.length) return { form: 100, rpe: 7, hitTop: true };
        const form = sets.reduce((a, b) => a + (b.formScore || 0), 0) / sets.length;
        const rpe = sets.reduce((a, b) => a + (b.rpe || 7), 0) / sets.length;
        const hitTop = sets.every((t) => t.hitTopRepRange);
        return { form, rpe, hitTop };
      }

      function walkCard() {
        const c = document.createElement("div");
        c.className = "card";
        const h = document.createElement("div");
        h.className = "name";
        h.textContent = "20-min Walk";
        const sub = document.createElement("div");
        sub.className = "sub";
        sub.textContent = "Start a 20:00 timer and move easy.";
        const row = document.createElement("div");
        row.className = "row";
        const timerBox = document.createElement("div");
        timerBox.className = "pill";
        timerBox.textContent = "20:00";
        const start = document.createElement("button");
        start.className = "btn";
        start.textContent = "Start";
        start.onclick = () => {
          const startMs = 20 * 60 * 1000;
          let left = startMs;
          const id = setInterval(() => {
            left -= 1000;
            timerBox.textContent = mmss(left);
            if (left <= 0) {
              clearInterval(id);
              Beep.beep(1200, 140, 0.06);
              Beep.beep(900, 160, 0.06);
              toast("Walk done. Nice.");
            }
          }, 1000);
        };
        row.appendChild(timerBox);
        row.appendChild(start);
        c.appendChild(h);
        c.appendChild(sub);
        c.appendChild(row);
        return c;
      }

      // Quick Log bottom sheet
      function openQuickLog({ cfg, setIndex, onSave }) {
        const sKey = cfg.id + "::last";
        window.__lastUsed = window.__lastUsed || {};
        const last = window.__lastUsed[sKey] || {};

        const isTime = !!cfg.timeSec;
        const defaultReps = isTime ? cfg.timeSec[1] : cfg.reps[1];
        const defaultWeight = typeof cfg.load === "number" ? cfg.load : 0;

        const backdrop = document.createElement("div");
        backdrop.className = "sheet-backdrop";
        const sheet = document.createElement("div");
        sheet.className = "sheet";

        const title = document.createElement("div");
        title.className = "title";
        title.textContent = `${cfg.name} — Set ${setIndex + 1}`;

        const grid = document.createElement("div");
        grid.className = "grid";

        let weightInput = null;
        if (defaultWeight > 0) {
          const wWrap = document.createElement("div");
          const wLab = document.createElement("div");
          wLab.className = "sub";
          wLab.textContent = "Weight (lb)";
          weightInput = document.createElement("input");
          weightInput.type = "number";
          weightInput.inputmode = "decimal";
          weightInput.placeholder = String(defaultWeight);
          weightInput.value = String(last.weightLb ?? defaultWeight);
          wWrap.appendChild(wLab);
          wWrap.appendChild(weightInput);
          grid.appendChild(wWrap);
        }

        const rWrap = document.createElement("div");
        const rLab = document.createElement("div");
        rLab.className = "sub";
        rLab.textContent = isTime ? "Seconds" : "Reps";
        const repsInput = document.createElement("input");
        repsInput.type = "number";
        repsInput.inputmode = "numeric";
        repsInput.placeholder = String(defaultReps);
        repsInput.value = String(last.value ?? defaultReps);
        rWrap.appendChild(rLab);
        rWrap.appendChild(repsInput);
        grid.appendChild(rWrap);

        const row = document.createElement("div");
        row.className = "row";
        const cancel = document.createElement("button");
        cancel.className = "btn";
        cancel.textContent = "Cancel";
        cancel.onclick = () => backdrop.remove();
        const save = document.createElement("button");
        save.className = "btn primary";
        save.textContent = "Save";
        save.onclick = () => {
          const w = weightInput ? Number(weightInput.value || defaultWeight) : 0;
          const repOrSec = Number(repsInput.value || defaultReps);
          window.__lastUsed[sKey] = { weightLb: w, value: repOrSec };
          onSave({ weightLb: w, repOrSec });
          backdrop.remove();
        };

        sheet.appendChild(title);
        sheet.appendChild(grid);
        sheet.appendChild(document.createElement("div")).className = "hr";
        sheet.appendChild(row);
        row.appendChild(cancel);
        row.appendChild(save);

        backdrop.appendChild(sheet);
        backdrop.onclick = (e) => {
          if (e.target === backdrop) backdrop.remove();
        };
        document.body.appendChild(backdrop);
      }

      // Exercise card with set chips -> Quick Log -> rest after EVERY set
      function exerciseCard(cfg) {
        const card = document.createElement("div");
        card.className = "card ex";

        const left = document.createElement("div");
        const nm = document.createElement("div");
        nm.className = "name";
        nm.textContent = cfg.name;
        const mt = document.createElement("div");
        mt.className = "meta";
        const repTxt = cfg.timeSec ? `${cfg.timeSec[0]}–${cfg.timeSec[1]}s` : `${cfg.reps[0]}–${cfg.reps[1]} reps`;
        mt.textContent = `${cfg.sets} sets · ${repTxt}` + (cfg.load ? ` · Target: ${cfg.load} lb` : "");
        left.appendChild(nm);
        left.appendChild(mt);

        const right = document.createElement("div");
        right.className = "chips";

        for (let i = 0; i < cfg.sets; i++) {
          const c = document.createElement("div");
          c.className = "chip";
          c.textContent = i + 1;
          c.onclick = () => {
            if (c.dataset.done === "1") return;
            openQuickLog({
              cfg,
              setIndex: i,
              onSave: ({ weightLb, repOrSec }) => {
                c.dataset.done = "1";
                c.classList.add("done");
                Beep.beep(760, 100, 0.04);
                bufferSetLog(cfg, i, weightLb, repOrSec);
                autoRest(cfg.restSec, card);
              },
            });
          };
          right.appendChild(c);
        }

        card.appendChild(left);
        card.appendChild(right);

        if (cfg.constitution) {
          const cons = document.createElement("div");
          cons.className = "cue";
          const key = cfg.constitution === "swing" ? Constitution.swing[0] : Constitution.row[0];
          cons.innerHTML = `<strong>Form check:</strong> ${key} · <em>No rounding.</em> `;
          const ok = document.createElement("input");
          ok.type = "checkbox";
          ok.style.marginLeft = "8px";
          cons.appendChild(ok);
          card.appendChild(cons);
        }

        if (cfg.cues?.length) {
          const cue = document.createElement("div");
          cue.className = "cue";
          cue.textContent = "Cues: " + cfg.cues.join(" · ");
          card.appendChild(cue);
        }

        return card;
      }

      function autoRest(seconds, parentCard) {
        const old = parentCard.querySelector(".restbar");
        if (old) old.remove();
        const oldRow = parentCard.querySelector('.row[data-rest="1"]');
        if (oldRow) oldRow.remove();

        const bar = document.createElement("div");
        bar.className = "restbar";
        const fill = document.createElement("span");
        bar.appendChild(fill);

        const row = document.createElement("div");
        row.className = "row";
        row.setAttribute("data-rest", "1");
        const lbl = document.createElement("div");
        lbl.className = "sub";
        lbl.textContent = "Rest";
        const left = document.createElement("div");
        left.className = "pill";
        left.textContent = mmss(seconds * 1000);
        const skip = document.createElement("button");
        skip.className = "btn";
        skip.textContent = "Skip";
        skip.onclick = () => cleanup();

        row.appendChild(lbl);
        row.appendChild(left);
        row.appendChild(skip);

        parentCard.appendChild(row);
        parentCard.appendChild(bar);

        const stop = restTimer(
          seconds,
          (secLeft, prog) => {
            fill.style.width = `${Math.floor(prog * 100)}%`;
            left.textContent = mmss(secLeft * 1000);
          },
          () => cleanup()
        );

        function cleanup() {
          stop();
          bar.remove();
          row.remove();
        }
      }

      // Per-set buffer (session)
      function bufferSetLog(cfg, setIndex, weightLb, repOrSec) {
        window.__sessionBuffer = window.__sessionBuffer || [];
        const isTime = !!cfg.timeSec;
        window.__sessionBuffer.push({
          exerciseId: cfg.id,
          setIndex,
          weightLb: isNaN(weightLb) ? 0 : weightLb,
          reps: isTime ? null : repOrSec,
          seconds: isTime ? repOrSec : null,
          rpe: 7,
          formScore: 90,
          hitTopRepRange: true,
          notes: "",
        });
      }

      function finishRow() {
        const r = document.createElement("div");
        r.className = "row";
        const finish = document.createElement("button");
        finish.className = "btn primary block";
        finish.textContent = "Finish Workout";
        finish.onclick = () => finishWorkout();
        r.appendChild(finish);
        return r;
      }

      function finishWorkout() {
        stopWorkoutTimer();
        const s = Store.get();
        const sec = s.runtime.lastTotalSec;
        const sets = window.__sessionBuffer || [];
        const session = {
          id: uid(),
          workoutId: s.profile.track,
          date: nowISO(),
          totalSec: sec,
          sets,
        };
        Store.mutate((st) => {
          st.logs.push(session);
          st.runtime.warmupDoneKey = null;
        });
        window.__sessionBuffer = [];
        toast("Session saved. Total: " + mmss(sec * 1000));
        render();
      }

      // Metrics — per-routine only, with full set details
      function viewMetrics() {
        const wrap = document.createElement("div");
        wrap.className = "stack";

        wrap.appendChild(routineMetricsCard("Hybrid"));
        wrap.appendChild(routineMetricsCard("IronFocused"));
        wrap.appendChild(routineMetricsCard("GrumpyBack"));

        return wrap;
      }

      function buildExerciseNameMap() {
        const map = {};
        ["Hybrid", "IronFocused"].forEach((tid) => {
          (Tracks[tid].exercises || []).forEach((ex) => (map[ex.id] = ex.name));
        });
        planBExercises().forEach((ex) => (map[ex.id] = ex.name));
        return map;
      }

      function routineMetricsCard(id) {
        const s = Store.get();
        const exNames = buildExerciseNameMap();
        const card = document.createElement("div");
        card.className = "card";

        const title = document.createElement("div");
        title.className = "h";
        title.textContent = Tracks[id].title;

        const sub = document.createElement("div");
        sub.className = "sub";
        sub.textContent = Tracks[id].subtitle || "";

        const list = document.createElement("div");
        list.className = "stack";
        const logs = s.logs.filter((l) => l.workoutId === id).slice(-12).reverse();

        if (!logs.length) {
          const none = document.createElement("div");
          none.className = "pill";
          none.textContent = "No sessions yet.";
          list.appendChild(none);
        } else {
          logs.forEach((l) => {
            const row = document.createElement("div");
            row.className = "stack";

            const summary = document.createElement("div");
            summary.className = "row";
            const txt = document.createElement("div");
            txt.className = "pill";
            txt.textContent =
              new Date(l.date).toLocaleDateString() +
              " · Sets: " +
              (l.sets?.length || 0) +
              " · Time: " +
              mmss((l.totalSec || 0) * 1000);
            const del = document.createElement("button");
            del.className = "btn";
            del.textContent = "Delete";
            del.onclick = () => {
              showConfirmDialog("Delete this session?", () => {
                deleteSessionById(l.id);
              });
            };
            summary.appendChild(txt);
            summary.appendChild(del);

            const details = document.createElement("div");
            details.className = "stack";
            const groups = {};
            (l.sets || []).forEach((t) => {
              (groups[t.exerciseId] || (groups[t.exerciseId] = [])).push(t);
            });

            Object.keys(groups).forEach((exId) => {
              const sets = groups[exId].sort((a, b) => a.setIndex - b.setIndex);
              const block = document.createElement("div");
              block.className = "card";
              const name = document.createElement("div");
              name.className = "name";
              name.textContent = exNames[exId] || exId;
              const lines = document.createElement("div");
              lines.className = "stack";

              sets.forEach((t) => {
                const line = document.createElement("div");
                line.className = "sub";
                const w =
                  t.weightLb && t.weightLb > 0 ? `${t.weightLb} lb` : "BW";
                const repOrSec =
                  t.seconds != null
                    ? `${t.seconds}s${t.weightLb && t.weightLb > 0 ? " @ " + w : ""}`
                    : `${t.reps} reps${t.weightLb && t.weightLb > 0 ? " @ " + w : ""}`;
                line.textContent = `S${(t.setIndex || 0) + 1}: ${repOrSec}`;
                lines.appendChild(line);
              });

              block.appendChild(name);
              block.appendChild(lines);
              details.appendChild(block);
            });

            row.appendChild(summary);
            row.appendChild(details);
            list.appendChild(row);
          });
        }

        const actions = document.createElement("div");
        actions.className = "row";
        const exp = document.createElement("button");
        exp.className = "btn";
        exp.textContent = "Export CSV";
        exp.onclick = () => downloadRoutineCSV(id);

        card.appendChild(title);
        if (sub.textContent) card.appendChild(sub);
        card.appendChild(divider());
        card.appendChild(list);
        card.appendChild(divider());
        card.appendChild(actions);
        actions.appendChild(exp);
        return card;
      }

      function deleteSessionById(id) {
        Store.mutate((st) => {
          st.logs = st.logs.filter((x) => x.id !== id);
        });
        toast("Session deleted.");
        render();
      }

      function downloadRoutineCSV(id) {
        const s = Store.get();
        const rows = [
          [
            "sessionId",
            "date",
            "workoutId",
            "totalSec",
            "exerciseId",
            "setIndex",
            "weightLb",
            "reps",
            "seconds",
            "rpe",
            "formScore",
          ].join(","),
        ];
        s.logs
          .filter((l) => l.workoutId === id)
          .forEach((l) => {
            if (!l.sets?.length) {
              rows.push(
                [l.id, l.date, l.workoutId, l.totalSec || 0, "", "", "", "", "", "", ""].join(",")
              );
            } else {
              l.sets.forEach((t) => {
                rows.push(
                  [
                    l.id,
                    l.date,
                    l.workoutId,
                    l.totalSec || 0,
                    t.exerciseId,
                    t.setIndex,
                    t.weightLb || "",
                    t.reps || "",
                    t.seconds || "",
                    t.rpe || "",
                    t.formScore || "",
                  ].join(",")
                );
              });
            }
          });
        const blob = new Blob([rows.join("\n")], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download =
          "fitforge-" + (Tracks[id]?.title || id).replace(/\s+/g, "_") + ".csv";
        a.click();
        URL.revokeObjectURL(url);
      }

      // Learn View (essentials)
      function viewLearn() {
        const wrap = document.createElement("div");
        wrap.className = "stack";

        const con = document.createElement("div");
        con.className = "card";
        con.innerHTML = `
          <div class="h">The Lumbar Constitution</div>
          <div class="sub">These guard your back on swings and rows.</div>
          <div class="hr"></div>
          <div class="h" style="font-weight:700">KB Swings</div>
          <div class="sub">
            • Hinge at hips; butt to wall<br/>
            • Arms = ropes; bell = pendulum<br/>
            • Brace before hike; ribs down<br/>
            • Top = plank; bell ≤ chest<br/>
            • No rounding at bottom
          </div>
          <div class="hr"></div>
          <div class="h" style="font-weight:700">Bent-Over Rows</div>
          <div class="sub">
            • Hinge ~45°; feel hamstrings<br/>
            • Back flat as a table<br/>
            • Inhale, brace, pull; exhale top<br/>
            • Elbow drives back; squeeze blade<br/>
            • No twisting; drop weight if needed
          </div>
        `;
        wrap.appendChild(con);

        const prog = document.createElement("div");
        prog.className = "card";
        prog.innerHTML = `
          <div class="h">Progression: Add Before You Load</div>
          <div class="sub">
            • Weeks 1–2: Nail form at 35 lb KB / 25 lb DB (aim 12 reps)<br/>
            • Weeks 3–4: Add a set or 4s eccentric<br/>
            • Week 5+: +5 lb only if reps are clean (drop to 8, rebuild)
          </div>
        `;
        wrap.appendChild(prog);

        return wrap;
      }

      // Kickoff + iOS zoom guards
      window.addEventListener("hashchange", render);
      window.addEventListener("load", () => {
        render();

        // iOS: prevent accidental zoom (double-tap / pinch)
        let lastTouchEnd = 0;
        document.addEventListener(
          "touchend",
          (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
              e.preventDefault();
            }
            lastTouchEnd = now;
          },
          { passive: false }
        );
        document.addEventListener(
          "gesturestart",
          (e) => {
            e.preventDefault();
          },
          { passive: false }
        );
        document.addEventListener(
          "dblclick",
          (e) => {
            e.preventDefault();
          },
          { passive: false }
        );

        window.addEventListener("offline", () =>
          toast("Offline: PWA cache active.")
        );
        window.addEventListener("online", () =>
          toast("Online: syncing...")
        );
      });
    </script>
  </body>
</html>
